[{"type":"element","tagName":"h1","attributes":[],"children":[{"type":"text","content":"在 Javascript 中有哪些方法能够创建一个对象?他们适用于什么场景下"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h2","attributes":[],"children":[{"type":"text","content":"Answer"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"Object 语法"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"通常用于对出现过的数据进行缓存。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"const person = {\n  name: &quot;John&quot;,\n  age: 50,\n  birthday() {\n    this.age++\n  }\n}\nperson.birthday() // person.age === 51\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"构造函数"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"通常在需要创建对象的多个实例时使用，每个实例都有自己的数据，而相互之间没有影响。在调用构造函数之前必须使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"new"}]},{"type":"text","content":" 运算符，否则将会改变全局对象。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"function Person(name, age) {\n  this.name = name\n  this.age = age\n}\nPerson.prototype.birthday = function() {\n  this.age++\n}\nconst person1 = new Person(&quot;John&quot;, 50)\nconst person2 = new Person(&quot;Sally&quot;, 20)\nperson1.birthday() // person1.age === 51\nperson2.birthday() // person2.age === 21\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"工厂函数"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"创建一个类似于构造函数的新对象，但可以使用闭包存储私有数据，这样就使得新对象的方法，不需要 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"this"}]},{"type":"text","content":" 指针就可以访问内部数据。同时在调用函数或 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"this"}]},{"type":"text","content":" 关键字之前也不需要使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"new"}]},{"type":"text","content":"。工厂函数通常会抛弃原型的概念，并将所有属性和方法保留为对象的自有属性。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"const createPerson = (name, age) =&gt; {\n  const birthday = () =&gt; person.age++\n  const person = { name, age, birthday }\n  return person\n}\nconst person = createPerson(&quot;John&quot;, 50)\nperson.birthday() // person.age === 51\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"Object.create()"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"对新创建的对象的原型进行修改。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"const personProto = {\n  birthday() {\n    this.age++\n  }\n}\nconst person = Object.create(personProto)\nperson.age = 50\nperson.birthday() // person.age === 51\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"第二个参数也可以提供给 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"Object.create"}]},{"type":"text","content":"，它充当要定义的新属性的描述符。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"Object.create(personProto, {\n  age: {\n    value: 50,\n    writable: true,\n    enumerable: true\n  }\n})\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h2","attributes":[],"children":[{"type":"text","content":"Good to hear"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"ul","attributes":[],"children":[{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"原型是一个对象，主要用于从中父对象中继承属性和方法;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"工厂函数通过闭包提供私有属性和方法，但增加内存使用量作为代价，虽然类没有私有属性或方法，但通过复用单个原型对象来减少内存影响。"}]},{"type":"text","content":"\n"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"Additional links"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"&lt;!-- tags: (javascript) --&gt;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"&lt;!-- expertise: (1) --&gt;"}]},{"type":"text","content":"\n"}]