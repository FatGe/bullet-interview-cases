[{"type":"element","tagName":"h1","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":"，"},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":"，"},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"const"}]},{"type":"text","content":" 和没有关键字的语句有什么区别"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h2","attributes":[],"children":[{"type":"text","content":"Answer"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"No keyword"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"如果在变量赋值之前不存在关键字，如果不存在全局变量，则赋值给全局变量，或重新赋值已声明的变量。在非严格模式下，如果尚未声明变量，它将把变量指定为全局对象的属性（浏览器中的"},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"window"}]},{"type":"text","content":"）。在严格模式下，它将抛出错误以防止创建不需要的全局变量。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":" 是ES2015之前声明变量的默认语句。 它创建一个函数范围的变量，可以重新分配和重新声明。但是，由于缺少块作用域，如果变量在包含异步回调的循环中重用，则可能会导致问题，因为变量在块作用域之外一直存在。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"例如，在执行"},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"setTimeout"}]},{"type":"text","content":"回调时，循环已经完成，"},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"i"}]},{"type":"text","content":"变量为'10`，因此所有十个回调都引用了函数作用域中可用的相同变量。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"for (var i = 0; i &lt; 10; i++) {\n  setTimeout(() =&gt; {\n    // logs `10` ten times\n    console.log(i)\n  })\n}\n\n/* Solutions with `var` */\nfor (var i = 0; i &lt; 10; i++) {\n  // Passed as an argument will use the value as-is in\n  // that point in time\n  setTimeout(console.log, 0, i)\n}\n\nfor (var i = 0; i &lt; 10; i++) {\n  // Create a new function scope that will use the value\n  // as-is in that point in time\n  ;(i =&gt; {\n    setTimeout(() =&gt; {\n      console.log(i)\n    })\n  })(i)\n}\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":" 在ES2015中引入，是声明后将重新赋值的变量的首选方式。但是如果尝试再次重新声明变量将导致错误。此外它是块作用域的，因此在循环中使用它将使其作用于迭代。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"for (let i = 0; i &lt; 10; i++) {\n  setTimeout(() =&gt; {\n    // logs 0, 1, 2, 3, ...\n    console.log(i)\n  })\n}\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h3","attributes":[],"children":[{"type":"text","content":"const"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"const"}]},{"type":"text","content":" 在ES2015中引入，如果变量以后不会被重新赋值，那么它是首选的声明方式。此外它存在与块状作用域，不能重新赋值。"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"pre","attributes":[],"children":[{"type":"element","tagName":"code","attributes":[{"key":"class","value":"language-es6"}],"children":[{"type":"text","content":"const myObject = {}\nmyObject.prop = &quot;hello!&quot; // No error\nmyObject = &quot;hello&quot; // Error\n"}]}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h2","attributes":[],"children":[{"type":"text","content":"Good to hear"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"ul","attributes":[],"children":[{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"所有声明都应该在其作用域的顶部;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"然而，使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":" 和 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"const"}]},{"type":"text","content":"，有一个称为暂时死区（TDZ）的概念。意思是说由let/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"显示使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":" 以及 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":" 如何解决它的常见问题，以及保持 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":" 的解决方案;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"text","content":"应尽可能避免使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"var"}]},{"type":"text","content":"，并且更喜欢 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"const"}]},{"type":"text","content":" 作为所有变量的默认声明语句，除非它们稍后会被重新分配，那就应当使用 "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":"。"}]},{"type":"text","content":"\n"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"h2","attributes":[],"children":[{"type":"text","content":"Additional links"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"ul","attributes":[],"children":[{"type":"text","content":"\n"},{"type":"element","tagName":"li","attributes":[],"children":[{"type":"element","tagName":"a","attributes":[{"key":"href","value":"https://wesbos.com/let-vs-const/"}],"children":[{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"let"}]},{"type":"text","content":" vs "},{"type":"element","tagName":"code","attributes":[],"children":[{"type":"text","content":"const"}]}]}]},{"type":"text","content":"\n"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"&lt;!-- tags: (javascript) --&gt;"}]},{"type":"text","content":"\n"},{"type":"element","tagName":"p","attributes":[],"children":[{"type":"text","content":"&lt;!-- expertise: (1) --&gt;"}]},{"type":"text","content":"\n"}]